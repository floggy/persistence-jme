 ------
 Datatypes
 ------
 Thiago Rossato
 ------
 18 September 2007
 ------

Datatypes and theirs size

	The table below shows the data types that are Floggy compliant and their size.
	All primitive types are saved using only the size of that type.
	Object types receive one extra byte that indicates the state of the object (null or not).
	Only fields of a class that implements net.sourceforge.floggy.Persistable will be persisted.

*----------*--------------*------------------------*
| Type   | Default value | Size |
*----------*--------------*------------------------*
| boolean   | false     |1 byte|
*----------*--------------*------------------------*
| byte   | 0     |1 byte|
*----------*--------------*------------------------*
| char   | 0     |2 bytes|
*----------*--------------*------------------------*
| double | 0.0	|8 bytes|
*----------*--------------*------------------------*
| float  | 0.0	|4 bytes|
*----------*--------------*------------------------*
| int    | 0     |4 bytes |
*----------*--------------*------------------------*
| long   | 0     |8 bytes |
*----------*--------------*------------------------*
| short    | 0     | 2 bytes|
*----------*--------------*------------------------*
| java.lang.Boolean | null     | 1 byte if value is null; 2 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Byte | null     | 1 byte if the value is null or 2 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Character | null     | 1 byte if the value is null or 3 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Double | null     | 1 byte if the value is null or 9 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Float | null     | 1 byte if the value is null or 5 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Integer | null     | 1 byte if the value is null or 5 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Long | null     | 1 byte if the value is null or 9 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.Short | null     | 1 byte if the value is null or 3 bytes otherwise|
*----------*--------------*------------------------*
| java.lang.String | null     | 1 byte if the value is null, otherwise the size is calculated based on the {{{http://java.sun.com/javase/6/docs/api/java/io/DataInput.html#modified-utf-8}Modified UTF-8}} specification|
*----------*--------------*------------------------*
| java.util.Date | null     | 1 byte if the value is null or 9 bytes otherwise. The java.util.Date objects are transformed into a long type and saved as a java.lang.Long object|
*----------*--------------*------------------------*
| java.util.Vector | null     | 1 byte if the value is null|
*----------*--------------*------------------------*
| net.sourceforge.floggy.Persistable | null     | 1 byte if the value is null|
*----------*--------------*------------------------*

		Examples
	
	Suppose that you have a class like this:
	
+------------------------------+
public class Frog implements Persistable {
        
        private String name;
        private Date bornDate;
        private char sex;
}
+------------------------------+

	Now suppose this three scenarios:
	
	[1] A instance of Frog with <<null>> name, <<null>> bornDate and <<0>> sex. The total cost of store this instance is: 
		(1 byte) + (1 byte) + (2 bytes)= 4 bytes. This happens because no value must be save for name and bornDate only one byte indicating nullable state.
		
	[2] A instance of Frog with <<Flip Flop>> name, <<05-30-2007>> bornDate and <<M>> sex. The total cost of store this instance is:
		(1 byte + 9 bytes) + (1 byte + 8 bytes) + (2 bytes)= 21 bytes. This happens because the values for name and bornDate doesn't are null.
		
	[3] A instance of Frog with <<null>> name, <<05-30-2007>> bornDate and <<F>> sex. The total cost of store this instance is:
		(1 byte) + (1 byte + 8 bytes) + (2 bytes)= 12 bytes. This happens because the value of name are null.
		